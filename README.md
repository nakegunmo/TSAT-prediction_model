BTC価格の極小・極大予測 Transformerモデル
概要 🚀
このプロジェクトは、Transformerモデルとソフトラベリング技術を用いて、ビットコイン（BTC）の5分足価格データから、価格の極小点（買いシグナル候補）と極大点（売りシグナル候補）を予測するためのものです。

モデルは、分類タスク（極小/極大/その他）と回帰タスク（将来価格の予測）を同時に学習するマルチタスク学習フレームワークを採用しています。

主な特徴 ✨
Transformerベースのモデル: 時系列データ内の長期的な依存関係やパターンを捉えるために、Transformer Encoderアーキテクチャを利用します。
スコアベースのソフトラベリング: 単純な「極小=1, 極大=2」といったハードラベルではなく、価格が周囲の価格と比べてどれだけ突出しているかの「度合い」をスコア化し、それを確率分布（ソフトラベル）としてモデルの学習ターゲットとすることで、より曖昧でノイズの多い金融データに対して柔軟な学習を目指します。
マルチタスク学習: 分類損失（KLダイバージェンス）と回帰損失（MSE）を組み合わせることで、モデルがより豊かな特徴表現を学習することを促します。
詳細な評価とシミュレーション: 標準的な分類メトリクスに加え、予測シグナルに基づいた損益（P&L）シミュレーションや、シグナル発生後の価格変動統計など、多角的な評価機能を提供します。
柔軟な設定: 学習やシミュレーションに関する主要なパラメータ（シーケンス長、バッチサイズ、閾値、分析期間など）は、スクリプトの先頭で簡単に変更可能です。
メモリ効率の良い予測: 大規模なデータを扱う際にメモリ不足に陥らないよう、予測処理を小さなバッチに分割して実行する機能を実装しています。
セットアップと実行方法 🔧
1. 前提条件
Python 3.8+
PyTorch
pandas
NumPy
scikit-learn
Matplotlib
tqdm
必要なライブラリは、以下のコマンドでインストールできます。

Bash

pip install torch pandas numpy scikit-learn matplotlib tqdm
2. データ準備
学習用 (BTC_full_5min_Train.csv) と検証用 (BTC_full_5min_Valid.csv) の価格データを用意します。

データは以下のカラムを含むCSV形式である必要があります。

date: 日時（例: 2023-01-01 00:05:00）
open, high, low, close: 四本値
volume: 出来高
スクリプト内の以下の変数を、実際のファイルパスに合わせて修正してください。

Python

# Step 2: ファイルパス定義
TRAIN_PATH = "path/to/your/BTC_full_5min_Train.csv"
VALID_PATH = "path/to/your/BTC_full_5min_Valid.csv"
3. 実行
Jupyter Notebook (.ipynb) またはPythonスクリプト (.py) を、上から順にセルまたはコードブロックを実行してください。

Step 1-9: データの読み込み、前処理、ラベル生成、モデル定義が行われます。
Step 10: 定義されたモデルの学習と、エポックごとの検証が行われます。最良の検証スコアを達成したモデルの重みが output_dir 内に best_transformer_model.pth として保存されます。
Step 11: 保存されたベストモデルを使い、テストデータに対する最終的な性能評価レポート（テキストファイルとCSV）を出力します。
Step 12: 保存されたベストモデルを使い、指定した期間の価格チャート上に予測シグナルをプロットし、損益シミュレーションを実行します。
モデル構造 🧠
モデルはPyTorchで実装されており、主に2つのクラスから構成されます。

PositionalEncoding: Transformerが入力の順序情報を理解できるように、各時点のデータに位置情報を付加します。
TransformerClassifierSoftLabel: メインのモデル。
入力: 4つの特徴量（正規化されたclose, high, low, volume）を持つ時系列シーケンス。
構造:
入力射影層: 4次元の特徴量をモデルの内部次元数（d_model）に変換します。
Positional Encoding: 位置情報を付加します。
Transformer Encoder: Multi-Head Self-Attention機構を用いて、シーケンス内の時間的パターンを学習します。
出力ヘッド: Encoderの最終出力（シーケンスの最後の時点のベクトル）を、2つの異なるヘッドに入力します。
分類ヘッド: 3クラス（その他, 極小, 極大）の確率を予測します。
回帰ヘッド: 1つの連続値を予測します（例: 将来の価格変動）。
損失関数: 分類タスクの KLダイバージェンス損失（ソフトラベル用）と、回帰タスクの 平均二乗誤差（MSE）損失を、重み付けして合計したものを最終的な損失として使用します。
評価とシミュレーション 📈
学習・検証 (Step 10): 各エポックで検証データに対する損失を計算し、ライブで損失グラフをプロットします。また、検証データに対する詳細な評価レポート（テキスト/CSV）もエポックごとに出力します。
テスト評価 (Step 11): 最良モデルを用いて、未知のテストデータに対する最終性能を評価します。レポートには混同行列、分類レポート、AUCスコア、将来リターン分析などが含まれます。
可視化と損益シミュレーション (Step 12):
指定した期間の価格チャート上に、モデルが生成した買い（極小）シグナルと売り（極大）シグナルをプロットします。
「極小シグナルで買い、次の極大シグナルで売る」というシンプルな戦略に基づいた損益シミュレーションを実行し、トレードログと合計損益を表示します。
シミュレーションは月単位で実行され、メモリ使用量が考慮されています。
主要な設定パラメータ ⚙️
スクリプト内の以下の変数を変更することで、モデルの挙動や実験設定を調整できます。

SEED: 再現性確保のための乱数シード。
SEQ_LEN: モデルに入力する時系列データの長さ（ウィンドウサイズ）。
BATCH: 学習時のバッチサイズ。
EPOCHS: 学習のエポック数。
PLOT_THRESHOLD_MIN_S12, PLOT_THRESHOLD_MAX_S12: Step 12でのシグナル判定に用いる確率の閾値。
PLOT_YEAR_S12: Step 12で分析・プロットする対象年。
PREDICTION_BATCH_SIZE_S12: Step 12での予測時のバッチサイズ。メモリ不足が発生する場合に調整します。
SIM_TRADE_UNIT_S12: Step 12での取引単位。
注意事項 ⚠️
このプロジェクトは、あくまで機械学習と金融データ分析に関する技術的な研究・実験を目的としています。本コードが出力する予測シグナルは、実際の金融取引を推奨または勧誘するものではありません。実際の取引に利用した結果生じたいかなる損害についても、作成者は一切の責任を負いません。
